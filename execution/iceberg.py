"""Iceberg order execution algorithm.

This module implements iceberg execution strategy that shows small visible
quantity while hiding large total order size from the market.
"""

from __future__ import annotations

import time
import uuid
from collections.abc import AsyncIterator
from typing import Literal

from core.bus import BusProto
from core.contracts import OrderIntent
from execution.base import BaseExecutor
from execution.contracts import ExecutionAlgorithm


class IcebergExecutor(BaseExecutor):
    """Iceberg order execution algorithm.

    Shows small "visible" quantity to the market while hiding the total order
    size. Automatically replenishes the visible portion as it fills.

    Attributes:
        strategy_id: Strategy ID for OrderIntent attribution
        visible_ratio: Ratio of total quantity to show (default 0.1 = 10%)
        replenish_threshold: Fill ratio that triggers replenishment (default 0.5 = 50%)
    """

    def __init__(
        self,
        strategy_id: str,
        visible_ratio: float = 0.1,
        replenish_threshold: float = 0.5,
    ) -> None:
        """Initialize Iceberg executor.

        Args:
            strategy_id: Strategy ID for OrderIntent attribution
            visible_ratio: Ratio of total quantity to show (0 < ratio <= 1)
            replenish_threshold: Fill ratio that triggers replenishment (0 < threshold <= 1)

        Raises:
            ValueError: If visible_ratio or replenish_threshold out of valid range
        """
        super().__init__(strategy_id)
        if not 0 < visible_ratio <= 1:
            raise ValueError(f"visible_ratio must be in (0, 1], got {visible_ratio}")
        if not 0 < replenish_threshold <= 1:
            raise ValueError(f"replenish_threshold must be in (0, 1], got {replenish_threshold}")
        self.visible_ratio = visible_ratio
        self.replenish_threshold = replenish_threshold

    async def plan_execution(self, algo: ExecutionAlgorithm) -> list[OrderIntent]:
        """Plan initial iceberg OrderIntent.

        Generates the first visible portion of the iceberg order.
        Subsequent replenishment intents are generated by _monitor_and_replenish.

        Args:
            algo: Execution algorithm configuration

        Returns:
            List with single OrderIntent for visible portion

        Note:
            Each OrderIntent.meta includes:
            - execution_id: Unique execution identifier
            - slice_id: Slice identifier within this execution
            - algo_type: "Iceberg"
            - total_quantity: Total quantity (hidden from market)
            - visible_ratio: Visible ratio parameter
        """
        # Generate unique execution ID
        execution_id = f"iceberg_{uuid.uuid4().hex[:8]}"

        # Calculate visible quantity
        visible_qty = algo.total_quantity * self.visible_ratio

        # Get limit price from params
        if "limit_price" not in algo.params:
            raise ValueError(
                "limit_price must be provided in algo.params for iceberg orders. "
                "Provide params={'limit_price': <price>}"
            )
        price = algo.params["limit_price"]
        if not isinstance(price, (int, float)):
            raise TypeError(f"limit_price must be a number, got {type(price).__name__}")
        limit_price = float(price)
        if limit_price <= 0:
            raise ValueError(f"limit_price must be > 0, got {limit_price}")

        # Current time as base
        start_ts_ns = int(time.time() * 1e9)

        # Create initial visible intent
        intent = self._create_visible_intent(
            execution_id=execution_id,
            slice_idx=0,
            symbol=algo.symbol,
            side=algo.side,
            visible_qty=visible_qty,
            total_qty=algo.total_quantity,
            limit_price=limit_price,
            scheduled_ts_ns=start_ts_ns,
        )

        return [intent]

    def _create_visible_intent(
        self,
        execution_id: str,
        slice_idx: int,
        symbol: str,
        side: Literal["buy", "sell"],
        visible_qty: float,
        total_qty: float,
        limit_price: float,
        scheduled_ts_ns: int,
    ) -> OrderIntent:
        """Create OrderIntent for visible portion of iceberg.

        Args:
            execution_id: Unique execution identifier
            slice_idx: Slice index (0 for initial, increments with replenishments)
            symbol: Trading pair symbol
            side: Order side (buy or sell)
            visible_qty: Visible quantity to show
            total_qty: Total quantity (hidden)
            limit_price: Limit price for order
            scheduled_ts_ns: Scheduled execution time (nanoseconds)

        Returns:
            OrderIntent with iceberg metadata packed in meta field
        """
        slice_id = f"{execution_id}_slice_{slice_idx}"

        # Pack iceberg metadata into meta field for fill tracking
        meta = {
            "execution_id": execution_id,
            "slice_id": slice_id,
            "algo_type": "Iceberg",
            "slice_idx": slice_idx,
            "total_quantity": total_qty,
            "visible_ratio": self.visible_ratio,
            "replenish_threshold": self.replenish_threshold,
        }

        return OrderIntent(
            id=slice_id,
            ts_local_ns=scheduled_ts_ns,
            strategy_id=self.strategy_id,
            symbol=symbol,
            side=side,
            type="limit",  # Iceberg orders are always limit orders
            qty=visible_qty,
            limit_price=limit_price,
            meta=meta,
        )

    async def _monitor_and_replenish(
        self, bus: BusProto, execution_id: str, algo: ExecutionAlgorithm
    ) -> AsyncIterator[OrderIntent]:
        """Monitor fills and yield replenishment OrderIntents.

        Tracks fills for this execution and yields new OrderIntents when
        the visible portion reaches the replenish threshold.

        Args:
            bus: Bus instance for subscribing to fills
            execution_id: Execution ID to filter fills
            algo: Original execution algorithm configuration

        Yields:
            OrderIntent instances for replenishment

        Note:
            This is a simplified implementation. Production version would
            handle timeouts, cancellations, price adjustments, and error cases.
        """
        # Get limit price from params
        limit_price = float(algo.params["limit_price"])

        # Track fills
        filled_quantity = 0.0
        current_slice_idx = 0
        current_visible_qty = algo.total_quantity * self.visible_ratio
        current_slice_filled = 0.0

        async for fill in self.track_fills(bus, execution_id):
            filled_quantity += fill.qty
            current_slice_filled += fill.qty

            # Check if we've reached replenish threshold for current slice
            fill_ratio = current_slice_filled / current_visible_qty
            if fill_ratio >= self.replenish_threshold:
                # Check if we still have quantity remaining
                remaining_quantity = algo.total_quantity - filled_quantity
                if remaining_quantity > 0.001:  # Small tolerance for floating point
                    # Calculate next visible quantity
                    next_visible_qty = min(
                        remaining_quantity, algo.total_quantity * self.visible_ratio
                    )

                    # Generate replenishment intent
                    current_slice_idx += 1
                    replenish_intent = self._create_visible_intent(
                        execution_id=execution_id,
                        slice_idx=current_slice_idx,
                        symbol=algo.symbol,
                        side=algo.side,
                        visible_qty=next_visible_qty,
                        total_qty=algo.total_quantity,
                        limit_price=limit_price,
                        scheduled_ts_ns=int(time.time() * 1e9),
                    )

                    # Reset tracking for new slice
                    current_visible_qty = next_visible_qty
                    current_slice_filled = 0.0

                    yield replenish_intent

            # Stop if total quantity filled
            if filled_quantity >= algo.total_quantity:
                break
