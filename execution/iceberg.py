"""Iceberg order execution algorithm.

This module implements iceberg execution strategy that shows small visible
quantity while hiding large total order size from the market.
"""

from __future__ import annotations

import time
import uuid
from collections.abc import AsyncIterator
from typing import Any, Literal

from core.bus import BusProto
from core.contracts import OrderIntent
from execution.base import BaseExecutor
from execution.contracts import ExecutionAlgorithm


class IcebergExecutor(BaseExecutor):
    """Iceberg order execution algorithm.

    Shows small "visible" quantity to the market while hiding the total order
    size. Automatically replenishes the visible portion as it fills.

    Attributes:
        strategy_id: Strategy ID for OrderIntent attribution
        visible_ratio: Ratio of total quantity to show (default 0.1 = 10%)
        replenish_threshold: Fill ratio that triggers replenishment (default 0.5 = 50%)
    """

    def __init__(
        self,
        strategy_id: str,
        visible_ratio: float = 0.1,
        replenish_threshold: float = 0.5,
    ) -> None:
        """Initialize Iceberg executor.

        Args:
            strategy_id: Strategy ID for OrderIntent attribution
            visible_ratio: Ratio of total quantity to show (0 < ratio <= 1)
            replenish_threshold: Fill ratio that triggers replenishment (0 < threshold <= 1)

        Raises:
            ValueError: If visible_ratio or replenish_threshold out of valid range
        """
        super().__init__(strategy_id)
        if not 0 < visible_ratio <= 1:
            raise ValueError(f"visible_ratio must be in (0, 1], got {visible_ratio}")
        if not 0 < replenish_threshold <= 1:
            raise ValueError(f"replenish_threshold must be in (0, 1], got {replenish_threshold}")
        self.visible_ratio = visible_ratio
        self.replenish_threshold = replenish_threshold

    async def plan_execution(self, algo: ExecutionAlgorithm) -> list[OrderIntent]:
        """Plan initial iceberg OrderIntent.

        Generates the first visible portion of the iceberg order.
        Subsequent replenishment intents are generated by _monitor_and_replenish.

        Args:
            algo: Execution algorithm configuration

        Returns:
            List with single OrderIntent for visible portion

        Note:
            Supports multiple price levels via params:
            - Single price: params={'limit_price': 50000.0}
            - Multiple levels: params={'price_levels': [50000.0, 49900.0, 49800.0]}

            Each OrderIntent.meta includes:
            - execution_id: Unique execution identifier
            - slice_id: Slice identifier within this execution
            - algo_type: "Iceberg"
            - total_quantity: Total quantity (hidden from market)
            - visible_ratio: Visible ratio parameter
            - price_levels: List of price levels (if multi-level mode)
        """
        # Generate unique execution ID
        execution_id = f"iceberg_{uuid.uuid4().hex[:8]}"

        # Calculate visible quantity
        visible_qty = algo.total_quantity * self.visible_ratio

        # Parse price configuration (single or multiple levels)
        price_levels = self._parse_price_levels(algo.params)

        # Current time as base
        start_ts_ns = int(time.time() * 1e9)

        # Create initial visible intent at first price level
        intent = self._create_visible_intent(
            execution_id=execution_id,
            slice_idx=0,
            symbol=algo.symbol,
            side=algo.side,
            visible_qty=visible_qty,
            total_qty=algo.total_quantity,
            limit_price=price_levels[0],
            scheduled_ts_ns=start_ts_ns,
            price_levels=price_levels,
        )

        return [intent]

    def _parse_price_levels(self, params: dict[str, Any]) -> list[float]:
        """Parse price levels from params (single or multiple).

        Args:
            params: Algorithm parameters

        Returns:
            List of price levels (length 1 for single price)

        Raises:
            ValueError: If neither limit_price nor price_levels provided
            ValueError: If price_levels is empty or contains invalid prices
        """
        # Check for multi-level configuration
        if "price_levels" in params:
            levels = params["price_levels"]
            if not isinstance(levels, list):
                raise TypeError(f"price_levels must be a list, got {type(levels).__name__}")
            if len(levels) == 0:
                raise ValueError("price_levels must not be empty")

            # Validate each price
            validated_levels: list[float] = []
            for i, price in enumerate(levels):
                if not isinstance(price, (int, float)):
                    raise TypeError(
                        f"price_levels[{i}] must be a number, got {type(price).__name__}"
                    )
                price_float = float(price)
                if price_float <= 0:
                    raise ValueError(f"price_levels[{i}] must be > 0, got {price_float}")
                validated_levels.append(price_float)

            return validated_levels

        # Fall back to single limit_price
        if "limit_price" not in params:
            raise ValueError(
                "Either limit_price or price_levels must be provided in algo.params. "
                "Provide params={'limit_price': <price>} or params={'price_levels': [<prices>]}"
            )

        price = params["limit_price"]
        if not isinstance(price, (int, float)):
            raise TypeError(f"limit_price must be a number, got {type(price).__name__}")
        limit_price = float(price)
        if limit_price <= 0:
            raise ValueError(f"limit_price must be > 0, got {limit_price}")

        return [limit_price]

    def _create_visible_intent(
        self,
        execution_id: str,
        slice_idx: int,
        symbol: str,
        side: Literal["buy", "sell"],
        visible_qty: float,
        total_qty: float,
        limit_price: float,
        scheduled_ts_ns: int,
        price_levels: list[float] | None = None,
    ) -> OrderIntent:
        """Create OrderIntent for visible portion of iceberg.

        Args:
            execution_id: Unique execution identifier
            slice_idx: Slice index (0 for initial, increments with replenishments)
            symbol: Trading pair symbol
            side: Order side (buy or sell)
            visible_qty: Visible quantity to show
            total_qty: Total quantity (hidden)
            limit_price: Limit price for this slice
            scheduled_ts_ns: Scheduled execution time (nanoseconds)
            price_levels: Full list of price levels (for multi-level mode)

        Returns:
            OrderIntent with iceberg metadata packed in meta field
        """
        slice_id = f"{execution_id}_slice_{slice_idx}"

        # Pack iceberg metadata into meta field for fill tracking
        meta: dict[str, Any] = {
            "execution_id": execution_id,
            "slice_id": slice_id,
            "algo_type": "Iceberg",
            "slice_idx": slice_idx,
            "total_quantity": total_qty,
            "visible_ratio": self.visible_ratio,
            "replenish_threshold": self.replenish_threshold,
        }

        # Include price_levels in metadata if multi-level mode
        if price_levels is not None and len(price_levels) > 1:
            meta["price_levels"] = price_levels

        return OrderIntent(
            id=slice_id,
            ts_local_ns=scheduled_ts_ns,
            strategy_id=self.strategy_id,
            symbol=symbol,
            side=side,
            type="limit",  # Iceberg orders are always limit orders
            qty=visible_qty,
            limit_price=limit_price,
            meta=meta,
        )

    async def _monitor_and_replenish(
        self, bus: BusProto, execution_id: str, algo: ExecutionAlgorithm
    ) -> AsyncIterator[OrderIntent]:
        """Monitor fills and yield replenishment OrderIntents.

        Tracks fills for this execution and yields new OrderIntents when
        the visible portion reaches the replenish threshold.

        For multi-level mode, rotates through price_levels for each replenishment.

        Args:
            bus: Bus instance for subscribing to fills
            execution_id: Execution ID to filter fills
            algo: Original execution algorithm configuration

        Yields:
            OrderIntent instances for replenishment

        Note:
            This is a simplified implementation. Production version would
            handle timeouts, cancellations, price adjustments, and error cases.
        """
        # Parse price levels (single or multiple)
        price_levels = self._parse_price_levels(algo.params)

        # Track fills
        filled_quantity = 0.0
        current_slice_idx = 0
        current_visible_qty = algo.total_quantity * self.visible_ratio
        current_slice_filled = 0.0

        async for fill in self.track_fills(bus, execution_id):
            filled_quantity += fill.qty
            current_slice_filled += fill.qty

            # Check if we've reached replenish threshold for current slice
            fill_ratio = current_slice_filled / current_visible_qty
            if fill_ratio >= self.replenish_threshold:
                # Check if we still have quantity remaining
                remaining_quantity = algo.total_quantity - filled_quantity
                if remaining_quantity > 0.001:  # Small tolerance for floating point
                    # Calculate next visible quantity
                    next_visible_qty = min(
                        remaining_quantity, algo.total_quantity * self.visible_ratio
                    )

                    # Generate replenishment intent
                    current_slice_idx += 1

                    # Rotate through price levels (modulo wraps around)
                    price_level_idx = current_slice_idx % len(price_levels)
                    next_limit_price = price_levels[price_level_idx]

                    replenish_intent = self._create_visible_intent(
                        execution_id=execution_id,
                        slice_idx=current_slice_idx,
                        symbol=algo.symbol,
                        side=algo.side,
                        visible_qty=next_visible_qty,
                        total_qty=algo.total_quantity,
                        limit_price=next_limit_price,
                        scheduled_ts_ns=int(time.time() * 1e9),
                        price_levels=price_levels,
                    )

                    # Reset tracking for new slice
                    current_visible_qty = next_visible_qty
                    current_slice_filled = 0.0

                    yield replenish_intent

            # Stop if total quantity filled
            if filled_quantity >= algo.total_quantity:
                break
